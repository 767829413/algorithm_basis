# 计算机基础知识

## 基本数学知识

`计算机上的一维坐标系`

 **选某一坐标为坐标原点，以某个方向为正方向，选择适当的标度建立一个坐标轴，就构成了一维坐标系，适于描述物体在一维。**

 ![1.jpg](https://s2.loli.net/2023/06/16/QmKTNjBbM1JZCpn.png)

`计算机上的二维坐标系`

 ![2.jpg](https://s2.loli.net/2023/06/16/yiMjLHAcVqZxK2u.png)

 计算机中表示二维数组的坐标系x轴是向下的，y轴是向上的。

 已知一条线经过原点(0,0)，并且和x轴所形成的夹角为45°，一次方程为: y=x。斜率就是 y/x = 1/1 = 1

 ![3.png](https://s2.loli.net/2023/06/16/tErX8lNmg2HF9nc.png)

 那么如果我们把此线段向右移动1，那么此时方程为y=x+1, 此时截距等于1

 ![4](https://pic.imgdb.cn/item/648bcec61ddac507cc82b105.png)

`四方向`

 ![5](https://pic.imgdb.cn/item/648bd03f1ddac507cc865b84.png)

 其中，中间的坐标为(x,y)，那么它上下左右四个方向的坐标为多少?

 ![6](https://pic.imgdb.cn/item/648bd1031ddac507cc889f21.png)

 那么，我们在以后做题的过程中，可能会遇到搜索四个方向的情况，此时我们就可以通过我们得到的数学关系，按照你喜欢或者题目要求的顺序，定义方向向量。
 
 **总结: x轴从上至下依次增大 (从北向南依次增大)，y轴从左至右依次增大 (从西向东依次增大);每走一格，根据方向增加或减少一个单位长度。**

`八方向`

 类似上面的四方向,也可以得出八个方向的向量

 ![7](https://pic.imgdb.cn/item/648bd2291ddac507cc8b5b82.png)

## 算法复杂度

`定义`

 **算法复杂度分为时间复杂度和空间复杂度。其作用: 时间复杂度是指执行算法所需要的计算工作量,而空间复杂度是指执行这个算法所需要的内存空间。 (算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间(即寄存器)资源，因此复杂度分为时间和空间复杂度。)**

 ![8](https://pic.imgdb.cn/item/648bd3541ddac507cc8e1714.png)

`时间复杂度`

 **一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算(最深层循环内的语句)与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析我们算法的时间复杂度，记为BigO,T(n) = O(f(n))，简写为O(n)。**

 在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大0符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况.

 在T(n) = O(f(n))这个式子中，O的含义是T(n)的数量级，其严格的数学定义是: 若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n0，使得当n >= n0时，都满足0 <= T(n) <= Cf(n)。

 **算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据数据的性质**

 例如给定一个int类型的数组A [0... n-1] 当中，查找给定值 k 的算法大致如下:

 ```go
 var i = n - 1
 for i >= 0 && A[i] != k {
    i--
 }
 return i
 ```

 该算法中第三行语句的频度不难发现实际上和n的规模有关，并且和A的各个元素的取值和k的取值都有关系。

* 如果A的所有元素中没有和k相等的元素，则第三行的代码的频度为f(n) = n
* 如果A的最后一个元素等于k，那么第三行代码的频度f(n)= 0

 这就是所谓的最坏和最好的时间复杂度，通过最坏和最好时间复杂度的概念我们可以得到平均时间复杂度。

* **最坏时间复杂度**: 最坏时间复杂度指的是最坏情况下，算法的时间复杂度，也就是我们上述代码第三行A的元素没有和K相等情况下的复杂度
* **最好时间复杂度**: 最好时间复杂度指的是在最好的情况下，算法的时间复杂度，例如A的最后一个元素恰好等于k。
* **平均时间复杂度**: 平均时间复杂度指的是所有可能输入实例在等概率出现的情况下，算法的期望运行时间。

我们再去分析一个算法或者一段代码的时间复杂度的时候，有以下两条规则:

* 加法规则 T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
* 乘法规则: T(n)= T1(n) \* T2(n) = O(f(n)) \* O(g(n)) = O(f(n)* g(n))

常见的时间复杂度有:

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

举例1: 

```go
for i := 0; i < 2 * n; i ++ { println(i) };
```

 O(n),我们for循环循环了2n次，因此时间复杂度为O(n)，不用考虑常数空间。

举例2:

```go
for i:=0; i<n; i++ {
    for j:=0; j<n; j++ {
        println(i,j)
    }
}
```

 O(n^2), 两重循环，所以为O(n^2)

举例3:

```go
var x = 2
for x < n / 2 {
    x = 2 * x
}
```

 O(logn), x乘以了若干次2之后依旧小于 n/2，所以x大概乘以了logn次

举例4:

```go
func fact(n int) int {
    if n <= 1 {
        return 1;
    }
    return n * fact(n-1)
}
```
 
 O(n), 其本质就是从n乘到1，乘了n次

举例5:

```go
count := 0;
for i:=0; i<n; i = i * 2 {
    for j:=0; j<n; j++ {
        count++
    }
} 
```
 
 O(nlogn), 第一层logn,第二层 n

`空间复杂度`

 **空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2), 空间复杂度是O(1)。而一般的递归算法就要有o(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。**

 算法的空间复杂度S(n)定义为该算法所耗费的存储空间，他是问题规模n的函数。记为S(n)=O(g(n))。

 一个算法或者程序在执行的时候所需要一些额外的存储空间来存放本身所用的命令、常数、变量和输入数据外，还需要要一些对数据机型操作的工作单元和存储一些为实现计算所需要信息的辅助空间。如果输入的数据所占空间只取决于问题本身，和算法无关，则只需分析除了输入和程序之外的额外空间。

 算法原地工作被称为原地修改算法，即所需的辅助空间为常量。即O(1)。


## 位运算